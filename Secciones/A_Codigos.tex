\section{Códigos}


\begin{listing}[H]
  \scriptsize
  \begin{minted}{cpp}
#include "Wire.h"
#include "LiquidCrystal_I2C.h"

// ------ Pines para periféricos ------
// Registro 8-bits 74LS595
const int CLK1 = 8;  // Clock
const int DROW = 11; // Data
const int LROW = 10; // Latch
// Registro 4-bits 74HC95
const int CLK2 = 9;  // Clock
const int DCOL = 12; // Data
// Joystick
const int JOY_X = A0;
const int JOY_Y = A1;
const int JOY_B = 2; // Botón
// Display LCD
LiquidCrystal_I2C lcd = LiquidCrystal_I2C(0x27, 16, 2);
// ------------------------------------

// -------- Variables globales --------
// Contador para multiplexing matrix
byte counter = 0;
// Lecturas del joystick
int val_x = 512;
int val_y = 512;
// Estado del juego
enum State { INIT, GAME, MENU, END } game_state;
// Posición del cazador y del blanco
// El tablero es de 8x8, por lo que 3 bits
// por componente es suficiente.
struct pos {
  byte x : 3;
  byte y : 3;
} player, goal;
// Matriz del juego
byte matrix[8] = {0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00};
// Contadores de tiempo para eventos periódicos
unsigned long disp_time = 0;
unsigned long game_time = 0;
unsigned long poll_time = 0;
// Cantidad de partidas jugadas, ganadas y perdidas
unsigned games = 0;
unsigned won = 0;
unsigned lost = 0;
// Buffer para hacer strings con formato
char strBuf[50];
// ------------------------------------

// Inicializar una partida nueva
void game_init() {
  clear_matrix();
  game_state = GAME;
  ++games;

  // Posición inicial del cazador
  do {
    player.x = random(0,7);
    player.y = random(0,7);
    // Asegurarse que el cazador no aparezca
    // al interior del muro
  } while ((player.x == 3 || player.x == 4) && (player.y == 3 || player.y == 4));

  // Posición inicial del blanco, asegurando
  // que no aparezca al interior del muro ni
  // sobre el jugador
\end{minted}

\end{listing}
\begin{listing}[H]
     \scriptsize
  \begin{minted}{cpp}

  do {
    goal.x = random(0,7);
    goal.y = random(0,7);
  } while ((goal.x == player.x && goal.y == player.y) ||
          ((goal.x == 3 || goal.x == 4) && (goal.y == 3 || goal.y == 4)));

  // Información de depuración por consola serial
  sprintf(strBuf, "P(%d,%d)", player.x, player.y);
  Serial.println(strBuf);
  sprintf(strBuf, "G(%d,%d)", goal.x, goal.y);
  Serial.println(strBuf);

  // Empezar a contar el tiempo de partida
  disp_time = millis();
  game_time = disp_time;
  poll_time = disp_time;
}

// Restablecer matriz de juego a estado vacío
void clear_matrix() {
  matrix[0] = 0x00;
  matrix[1] = 0x00;
  matrix[2] = 0x18;
  matrix[3] = 0x18;
  matrix[4] = 0x00;
  matrix[5] = 0x00;
  matrix[6] = 0x00;
  matrix[7] = 0x00;
}

void setup() {
  // Configuración de pines
  pinMode(CLK1, OUTPUT);
  pinMode(DROW, OUTPUT);
  pinMode(LROW, OUTPUT);
  pinMode(CLK2, OUTPUT);
  pinMode(DCOL, OUTPUT);
  pinMode(JOY_B, INPUT_PULLUP);

  // Utilizar un interrupt por hardware para
  // responder ante entrada mediante botón
  attachInterrupt(digitalPinToInterrupt(JOY_B), btn_handler, CHANGE);

  // Inicializar display LCD
  lcd.init();
  lcd.backlight();

  // -- Configuración de interrupts de tiempo --
  // Restablecer configuración de Timer1
  TCCR1A = 0;
  TCCR1B = 0;
  // WGM12: Restablecer contador de timer cuando alcance OCR1A
  // CS10: No utilizar prescaler (frecuencia = frecuencia clock)
  TCCR1B |= (1 << WGM12 ) | (1 << CS10);
  // OCIE1A: Habilitar interrupt cuando se alcance OCR1A
  // OCIE1B: Habilitar interrupt cuando se alcance OCR1B
  TIMSK1 |= (1 << OCIE1A) | (1 << OCIE1B);
  // OCR1A: Ciclos de reloj para interrupt A (16000 a 16MHz = 2.5kHz)
  // OCR1B: Ciclos de reloj para interrupt B
  OCR1A = 6400;
  OCR1B = 3200;
  // -------------------------------------------

  // Crear seed para valores aleatorios
  randomSeed(analogRead(A3));

  Serial.begin(9600);

  // Estado inicial ("Listo para jugar?")
  game_state = INIT;
  clear_matrix();
\end{minted}
\end{listing}
\begin{listing}[H]
     \scriptsize
  \begin{minted}{cpp}
  lcd.setCursor(3, 0);
  lcd.print("Listo para");
  lcd.setCursor(5, 1);
  lcd.print("jugar?");
}

void loop() {
  // Estado de partida en curso
  if (game_state == GAME) {
    // Esto sólo ocurre una vez cuando se inicia el juego
    if (disp_time == game_time) {
      lcd.clear();
      lcd.setCursor(0, 0);
      lcd.print("Partida ");
      lcd.print(games);
      lcd.setCursor(0,1);
      lcd.print("Tiempo 0.0s");
    } 
    
    // Cada 100ms actualizar tiempo transcurrido
    if (millis() - disp_time >= 100) {
      disp_time = millis();
      lcd.setCursor(7,1);
      lcd.print((disp_time - game_time) / 1000);
      lcd.setCursor(9,1);
      lcd.print(((disp_time - game_time) / 100) % 10);
    }

    // Cada 250ms leer entrada y mover al cazador
    // También se hace parpadear al blanco
    if (millis() - poll_time >= 250) {
      poll_time = millis();

      val_x = analogRead(JOY_X);
      val_y = analogRead(JOY_Y);

      // Borrar punto de cazador anterior
      matrix[player.y == 0 ? 7 : (player.y - 1)] ^= (1 << player.x);

      // Zona muerta de 256, o 50% de la resolución
      // Sólo se actualiza la posición si no se va a chocar con la pared o el borde
      if (val_x < 256 && (player.x > 0 && !(player.x == 5 && (player.y == 3 || player.y == 4)))) player.x -= 1;
      else if (val_x > 768 && (player.x < 7 && !(player.x == 2 && (player.y == 3 || player.y == 4)))) player.x += 1;
      if (val_y < 256 && (player.y < 7 && !(player.y == 2 && (player.x == 3 || player.x == 4)))) player.y += 1;
      else if (val_y > 758 && (player.y > 0 && !(player.y == 5 && (player.x == 3 || player.x == 4)))) player.y -= 1;

      // Actualizar bits en la matriz
      matrix[player.y == 0 ? 7 : (player.y - 1)] |= (1 << player.x);
      matrix[goal.y == 0 ? 7 : (goal.y - 1)] ^= (1 << goal.x);

      if (player.x == goal.x && player.y == goal.y) {
        // Si se alcanzó a llegar al blanco, ganar la partida
        game_state = END;
        disp_time = millis();
        clear_matrix();
        lcd.clear();
        lcd.setCursor(3, 0);
        lcd.print("Ganaste el");
        lcd.setCursor(3, 1);
        lcd.print("juego! :-)");
        ++won;
      } else if (millis() - game_time >= 5000) {
        // Si luego de 5s no se alcanzó a llegar, se pierde la partida
        game_state = END;
        disp_time = millis();
        clear_matrix();
        lcd.clear();
        lcd.setCursor(3, 0);
        lcd.print("Perdiste!");
        lcd.setCursor(6, 1);
\end{minted}
\end{listing}
\begin{listing}[H]
     \scriptsize
  \begin{minted}{cpp}
        lcd.print(":-(");
        ++lost;
      }
    }
  } else if (game_state == END && millis() - disp_time >= 3000) {
    // Si el estado es finalizado, esperar 3s y luego mostrar
    // partidas guardadas
    game_state = MENU;
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print("Ganadas : ");
    lcd.print(won);
    lcd.setCursor(0,1);
    lcd.print("Perdidas: ");
    lcd.print(lost);
  }
}

// Responder ante pulsación del botón
void btn_handler() {
  // Si el juego no está en transcurso, iniciar una partida nueva
  if (game_state != GAME) game_init();
  else {
    // Mostrar información de depuración
    sprintf(strBuf, "P(%d,%d)", player.x, player.y);
    Serial.println(strBuf);
  }
}

// ISR del Timer1 cuando alcanza OCR1A
ISR(TIMER1_COMPA_vect) {
  // Blanquear las filas para evitar ghosting
  digitalWrite(LROW, LOW);
  shiftOut(DROW, CLK1, LSBFIRST, 0x00);
  digitalWrite(LROW, HIGH);
  // Encender las columnas a escribir
  shiftOut(DCOL, CLK2, LSBFIRST, ~matrix[counter]);
  if (++counter == 8) counter = 0;
}

// ISR del Timer2 cuando alcanza OCR2A
ISR(TIMER1_COMPB_vect) {
  // Encender la fila que se va a utilizar
  digitalWrite(LROW, LOW);
  shiftOut(DROW, CLK1, LSBFIRST, (1 << counter));
  digitalWrite(LROW, HIGH);
}


      \end{minted}
  \caption{Codigo Implementado}
  \label{lst:cod-1}
\end{listing}

\clearpage
\begin{table}
  \centering
  \begin{tabular}{||c|c||}
    \hline
    Componente & Cantidad \\ \hline \hline
    74HC595 & $1$ \\ \hline
    74HC95 & $2$ \\ \hline 
    Cables & Varios \\ \hline
    Protoboard & $1$ \\ \hline
    Modulo Joystick & $1$ \\ \hline
    Modulo LCD1602 I2C & $1$ \\ \hline
    Matriz LED 8x8 & $1$ \\ \hline
    Arduino UNO & $1$ \\ \hline
    Resistencias $\SI{220}{\ohm}$ & $8$ \\ \hline
    Cable USB & $1$ \\ \hline 
  \end{tabular}
  \label{tab:materiales}
  \caption{Tabla de materiales}
\end{table}